# -*- coding: utf-8 -*-
"""Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_PC-WD7v4b2JEbNR-T6FpLj1fXSkVzvp
"""

# @title
import base64
!pip install cirq --quiet
import cirq
import cirq
import numpy as np
import cirq_web.bloch_sphere as bloch_sphere
import matplotlib.pyplot as plt
def binary_labels(num_qubits):
    return [bin(x)[2:].zfill(num_qubits) for x in range(2 ** num_qubits)]
plt.rcParams.update({'font.size': 8})
from random import choices
print("Libraries imported successfully!")

def create_key():
  basis_gates = {'Z' : cirq.I, 'X' : cirq.H}
  number_of_qubits = 1000
  my_qubits = cirq.NamedQubit.range(number_of_qubits, prefix ="q")
  bases = choices(['Z','X'], k = number_of_qubits)
  circuit = cirq.Circuit()
  for bit in range(number_of_qubits):
    circuit.append(basis_gates[bases[bit]](my_qubits[bit]))
  return (bases, circuit, basis_gates, number_of_qubits, my_qubits)

def receive_key(sender_bases, sender_circuit, basis_gates, number_of_qubits, my_qubits):
  bases = choices(['Z','X'], k = number_of_qubits)
  circuit = cirq.Circuit()
  for bit in range(number_of_qubits):
    circuit.append(basis_gates[bases[bit]](my_qubits[bit]))
  circuit.append(cirq.measure(my_qubits, key = 'receiver key'))
  bb84_circuit = sender_circuit + circuit
  sim = cirq.Simulator()
  results = sim.run(bb84_circuit)
  receiver_key = results.measurements['receiver key'][0]
  final_sender_key = []
  final_receiver_key = []
  for bit in range(number_of_qubits):
    if receiver_key[bit] == 1:
      if sender_bases[bit] == 'Z':
        final_sender_key.append(0)
      if sender_bases[bit] == 'X':
        final_sender_key.append(1)
      if bases[bit] == 'Z':
        final_receiver_key.append(1)
      if bases[bit] == 'X':
        final_receiver_key.append(0)
  num_bits_to_compare = int(len(final_sender_key) * .5)
  if final_sender_key[0:num_bits_to_compare] == final_receiver_key[0:num_bits_to_compare]:
    final_sender_key = final_sender_key[num_bits_to_compare:]
    final_receiver_key = final_receiver_key[num_bits_to_compare:]
    print('Keys are usable')

  else:
    print('Keys are unusable')
  return final_sender_key, final_receiver_key

def encode(key, clear):
    enc = []
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(clear[i]) + ord(key_c)) % 256)
        enc.append(enc_c)
    return base64.urlsafe_b64encode("".join(enc).encode()).decode()

def decode(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc).decode()
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)

final_keys = receive_key(*create_key())
sender_key = final_keys[0]
receiver_key = final_keys[1]
encoded_message = encode(str(sender_key),'The quick brown fox jumps over the lazy dog')
print(encoded_message)
decoded_message = decode(str(receiver_key), encoded_message)
print(decoded_message)